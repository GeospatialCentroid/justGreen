---
title: JustGreen Tool Report 
output:
  html_document:
      css: style.css
params:
  cityName: NA,
  state: NA 
---


```{r load_packages_functions, echo=FALSE, message=FALSE, warning=FALSE}
pacman::p_load(leaflet, dplyr, readr,sf, terra, plotly)
sf_use_s2(FALSE)
### function for control number of character after the decimal place 
sigfig <- function(vec, n=3){ 
### function to round values to N significant digits
# input:   vec       vector of numeric
#          n         integer is the required sigfig  
# output:  outvec    vector of numeric rounded to N sigfig
formatC(signif(vec,digits=n), digits=n,format="fg", flag="#") 
} 
## source gauge chart from app repo - will need to transfer eventually 
source("~/trueNAS/work/justGreenShiny/functions/gaugeChart.R")

```


```{r set input parameters, echo=FALSE, message=FALSE, warning=FALSE}
## all these features should be defined as input parameters before the rmd is called to better hand the path 
city <- params$cityName
state <-  params$state 
cityHealth <-read_csv("~/trueNAS/work/justGreen/data/products/healthMeasures/allCities_2023_morDemStroke_with10percentAdjust.csv") 
ctHealth <- read_csv("~/trueNAS/work/justGreen/data/products/healthMeasures/allCT_2023_morDemStroke_with10percentAdjust_svi.csv")
totalPop <- read_csv("~/trueNAS/work/justGreen/data/processed/top200_2023/totalPopCities.csv")
# files
cityFiles <- list.files("~/trueNAS/work/justGreen/data/processed/top200_2023", 
                        pattern = ".gpkg",
                        full.names = TRUE)
ctFiles <- list.files("~/trueNAS/work/justGreen/data/processed/censusGeographies", 
                        pattern = "ct.gpkg",
                        full.names = TRUE)

```

```{r filter datasets, echo=FALSE, message=FALSE, warning=FALSE}
# pop data 
tPop <- totalPop[totalPop$NAME == city, ] |> pull(totalPopulation)

# filter health data to city 
cH <- cityHealth[cityHealth$city == city, ]
ctH <- ctHealth[ctHealth$city == city, ]
# filter spatial data to state and city 
## city level 
cS <- terra::vect(cityFiles[grepl(pattern = state, x = cityFiles)])|>
  terra::makeValid()
cS <- cS[cS$NAME == city, ] 
## census tract 
ctS <- terra::vect(ctFiles[grepl(pattern = state, x = ctFiles)])|>
  terra::makeValid()
ctS <- ctS[ctS$GEOID %in% ctH$geoid, ] 
ctS$geoid <- ctS$GEOID
# join health data 
ctS <- terra::merge(x = ctS, y = ctH, by = "geoid") 

# crop the ct to the 
crop_ct <- terra::crop(ctS, cS)
# select the census tracts 
ct_select <- ctS[ctS$GEOID %in% crop_ct$GEOID,]

```



```{r values for report , echo=FALSE, message=FALSE, warning=FALSE}
# ndvi 
cityNDVI <-round(cH$meanNDVI, 3)
ndvi_sorted <- cityHealth |>
  arrange(desc(meanNDVI)) |>                 # Sort by mpg descending
  mutate(rank = row_number()) |>        # Create a column with the rank
  # Calculate percentile based on rank and total rows (n())
  mutate(percentile = (1 - (rank / n())) * 100) 
rankNDVI <- ndvi_sorted[ndvi_sorted$city == city, ] |>
  pull(percentile)
# population 
pop_sorted <- totalPop |>
  arrange(desc(totalPopulation)) |>                 # Sort by mpg descending
  mutate(rank = row_number()) |>        # Create a column with the rank
  # Calculate percentile based on rank and total rows (n())
  mutate(percentile = (1 - (rank / n())) * 100) 
rankPop <- pop_sorted[pop_sorted$NAME == city, ] |>
  pull(percentile)
pop20 <- cH$popOver20_2023
pop35 <- cH$popOver35_2023
pop55 <- as.numeric(cH$popOver55_2023)

# generate a table for visualization 
popTable <- data.frame(
  `total population` = tPop,
  `p20` = pop20,
  `p35` = pop35,
  `p55` = pop55
)

# Apply formatting
popTable_formated <- as.data.frame(
  lapply(popTable, function(x) {
    format(x, big.mark = ",", scientific = FALSE)
  })
)


```



## Green Spaces and Health Impact 
**Location:**  `r paste0(city, ", ",state)`
<br>
**Report Date:** `r Sys.Date()` 


## Your Green Space Overview
* **Current Vegetation Level (NDVI):** `r cityNDVI` (Scale: 0.0-1.0, where 1.0 = maximum vegetation) 
* **NDVI Ranking:** `r paste0(rankNDVI,"th percentile")` compared to similar US cities 
* **Population Ranking:** `r paste0(rankPop,"th percentile")` compared to the top 200 most populated US cities 

```{r population table, echo=FALSE, message=FALSE, warning=FALSE}
names(popTable_formated) <- c("Total Population", "Population Over 20", "Population Over 35", "Population Over 55")
knitr::kable(popTable_formated)
```



## How Your Area Compares
[Interactive gauge chart showing current NDVI level vs. city average and national benchmarks]

- made this figure "fat" as there is a lot of white space at the moment. Can adjust once we get some feed back on the figure in the shiny app as I'm current just using that function. 

```{r gauge plot, echo=FALSE, message=FALSE, warning=FALSE}
valueRange <- round(range(ndvi_sorted$meanNDVI), 2)
current_pal <- RColorBrewer::brewer.pal( n = 8, name = "BuGn")


gaugePlot(selectedRate = cityNDVI,
          valueRange =valueRange ,
          colorPalette = current_pal,
          title = "NDVI against known range of top 200 Cities" ,
          height = 400)
```


## Health Benefits of Current Green Spaces 
Based on scientific research, the current level of vegetation in your area provides these estimated annual health benefits: 

```{r healthMetrics for city, echo=FALSE, message=FALSE, warning=FALSE}
posRound <- function(value){
  abs(round(value, 0))
}

# mortality rate 
morRate <- posRound(cH$ls_Mortality)
# stroke rate 
strokeRate <- posRound(cH$ls_Stroke)
# dementia rate 
demRate <- posRound(cH$ls_Dementia)
```

### Lives Protected 
* **Premature Deaths Prevented:** `r morRate` deaths annually 
* **Stroke Cases Prevented:** `r strokeRate` cases annually
* **Dementia Cases Prevented:** `r demRate` cases annually 

## Potential for Improvement 
### Current vs. Target Scenarios 


```{r table for NDVI increase, echo=FALSE, message=FALSE, warning=FALSE}
# table names 
n1 <- c( "Scenario", "Vegetation Level (NDVI)", "Additional Lives Saved", "Additional Health Benefits - Stroke", "Additional Health Benefits - Dementia")
# caculate 10% change over baseline 
ndviChange <- cityNDVI - 0.1
# add 10% increase 
ndviDiff <- cityNDVI + (ndviChange*0.1)

# mortality rate 
morRate10 <- posRound(cH$ls_Mortality10)
# stroke rate 
strokeRate10 <- posRound(cH$ls_Stroke10)
# dementia rate 
demRate10 <- posRound(cH$ls_Dementia10)

# generate a table for visualization 
healthTable <- data.frame(
  `Scenario` = c("Current Level", "Moderate Increase (+10%)"),
  `Vegetation Level (NDVI)` = c(cityNDVI, ndviDiff),
  `Additional Lives Saved` = c(morRate, morRate10),
  `Additional Health Benefits - Stroke` = c(strokeRate, strokeRate10),
  `Additional Health Benefits - Dementia` = c(demRate, demRate10)
)

# Apply formatting
healthTable_formated <- as.data.frame(
  lapply(healthTable, function(x) {
    format(x, big.mark = ",", scientific = FALSE)
  })
)
# plot the table 
names(healthTable_formated) <- n1
knitr::kable(healthTable_formated)
```

## Where to Add Green Spaces 
[Map showing priority areas for vegetation expansion based on population density and current vegetation gaps] 

```{r leaflet map, echo=FALSE, message=FALSE, warning=FALSE}
# show a map of a 
## city boundaries - cS
## filter the ctS data to remove all NA values in NDVI 
ctFilter <- ct_select[!is.na(ct_select$meanNDVI), ]

## census tracts visualized with NDVI values - ctS 
pal <- colorNumeric(
  palette = "BuGn",
  domain = ctFilter$meanNDVI
)

# Create labels for the popups that appear when a tract is clicked
popup_labels <- paste(
  "<strong>Tract ID:</strong>", ctFilter$geoid, "<br/>",
  "<strong>NDVI:</strong>", round(ctFilter$meanNDVI,2) , "<br/>",
  "<strong>Population over 20:</strong>", round(ctFilter$over20,0) , "<br/>",
  "<strong>Lives Saved per 100,000:</strong>", posRound(ctFilter$ls_Mortality) , "<br/>"
) %>%
  lapply(htmltools::HTML)

# Build the Leaflet map
map <- leaflet() %>%
  # Add a base map layer (we're using OpenStreetMap)
  addProviderTiles(providers$CartoDB.Positron, group = "CartoDB") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group = "OSM") %>%
  # Add the census tracts, colored by population
  addPolygons(
    data = ctFilter, 
    fillColor = ~pal(meanNDVI),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    highlightOptions = highlightOptions(
      weight = 3,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = popup_labels,
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
    ),
    group = "Census Tracts"
  )|>
    # Add the Chicago city outline as a blue polygon
  addPolygons(
    data = cS,
    fill = FALSE,         # No fill for the boundary itself
    color = "#007BFF",    # A distinct blue color for the outline
    weight = 3,           # Make the line thicker
    opacity = 0.6,
    smoothFactor = 0.5,
    group = "City Outline"
  ) |>
  # Add a legend to explain the color scale
  addLegend(
    pal = pal,
    values = ctFilter$meanNDVI,
    opacity = 0.7,
    title = "NDVI by Tract",
    position = "bottomright"
  ) %>%
  # Add layer controls to toggle views
  addLayersControl(
    baseGroups = c( "CartoDB","OSM"),
    overlayGroups = c("City Outline", "Census Tracts"),
    options = layersControlOptions(collapsed = FALSE)
  )

map
```

## Environmental Justice Considerations 
### Green Space Access by Demographics 


```{r svi data, echo=FALSE, message=FALSE, warning=FALSE}
ct_data <- as.data.frame(ct_select)
quartile_breaks <- quantile(ct_data$RPL_THEMES)
ct_data$quantile <- ntile(ct_data$RPL_THEMES, 4)
ct_data$qNDVI <- ntile(ct_data$meanNDVI, 4)
# function for flipping values 
absRound <- function(val){
  round(abs(val), 2)
}

# average of all tracts 
ndvi1 = mean(ct_data$meanNDVI, na.rm=TRUE)
mortality1 = absRound(mean(ct_data$ls_Mortality, na.rm = TRUE))
dementia1 = absRound(mean(ct_data$ls_Dementia, na.rm = TRUE))
stroke1 = absRound(mean(ct_data$ls_Stroke, na.rm = TRUE))
pop1 = absRound(mean(ct_data$over20, na.rm = TRUE))
sviScore = absRound(mean(ct_data$RPL_THEMES, na.rm = TRUE))

# summarize the nvdi and healt metrics per quantile groups 
c2 <- ct_data |>
  dplyr::group_by(quantile)|>
  dplyr::summarise(
    svi = mean(RPL_THEMES, na.rm=TRUE),
    ndvi = mean(meanNDVI, na.rm=TRUE),
    populationOver20 = mean(over20, na.rm=TRUE),
    mortality = absRound(mean(ls_Mortality, na.rm = TRUE)),
    dementia = absRound(mean(ls_Dementia, na.rm = TRUE)),
    stroke = absRound(mean(ls_Stroke, na.rm = TRUE))
  )

tableData <- c2[c(1,4), c("quantile","svi", "ndvi", "populationOver20" ,"mortality")]
tableData$quantile <- c("Lowest SVI Scores", "Highest SVI Scores")

# plot the table 
names(tableData) <- c("SVI Rank", "Average SVI Score", "Greenness Measures", 
                      "Average Population Over 20", "Average Lives Saved")
knitr::kable(tableData)
```
**Priority for Equity:** Areas with the greatest health needs and lowest green space access should be prioritized for vegetation interventions. 

```{r svi map, echo=FALSE, message=FALSE, warning=FALSE}
## census tracts visualized with NDVI values - ctS 
pal <- colorNumeric(
  palette = "YlGnBu",
  domain = ct_select$RPL_THEMES
)

## select that census tracts in the 4 quintile for SVI 
q4 <- ct_data |>
  dplyr::filter(quantile == 4) |>
  dplyr::select(geoid) |>
  pull()
q4Tracts <- ct_select[ct_select$geoid %in% q4, ]


## select that census tracts in the for NDVI 
q4n <- ct_data |>
  dplyr::filter(qNDVI  == 1) |>
  dplyr::select(geoid) |>
  pull()
q4Tractsn <- ct_select[ct_select$geoid %in% q4n, ] |>
  terra::centroids(inside=TRUE)

# Create labels for the popups that appear when a tract is clicked
popup_labels <- paste(
  "<strong>Tract ID:</strong>", ct_select$geoid, "<br/>",
  "<strong>NDVI:</strong>", round(ct_select$meanNDVI,2) , "<br/>",
  "<strong>Population over 20:</strong>", round(ct_select$over20,0) , "<br/>",
  "<strong>SVI Score:</strong>", ct_select$RPL_THEMES , "<br/>"
) %>%
  lapply(htmltools::HTML)

# Build the Leaflet map
map <- leaflet() %>%
  # Add a base map layer (we're using OpenStreetMap)
  addProviderTiles(providers$CartoDB.Positron, group = "CartoDB") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group = "OSM") %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") %>%
  # Add the census tracts, colored by population
  addPolygons(
    data = ct_select, 
    fillColor = ~pal(RPL_THEMES),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    highlightOptions = highlightOptions(
      weight = 3,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = popup_labels,
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
    ),
    group = "Census Tracts"
  )|>
    # Add the Chicago city outline as a blue polygon
  addPolygons(
    data = cS,
    fill = FALSE,         # No fill for the boundary itself
    color = "#007BFF",    # A distinct blue color for the outline
    weight = 3,           # Make the line thicker
    opacity = 0.6,
    smoothFactor = 0.5,
    group = "City Outline"
  ) |>
    addPolygons(
    data = q4Tracts,
    fill = FALSE,         # No fill for the boundary itself
    color = "#feb24c",    # A distinct blue color for the outline
    weight = 3,           # Make the line thicker
    opacity = 0.6,
    smoothFactor = 0.5,
    group = "Highest SVI"
  ) |>
    addCircleMarkers(
    data = q4Tractsn,
    fill = FALSE,         # No fill for the boundary itself
    color = "#dd1c77",    # A distinct blue color for the outline
    weight = 2,           # Make the line thicker
    opacity = 1,
    radius = 1.2, 
    group = "Lowest Greenness"
  ) |>
  # Add a legend to explain the color scale
  addLegend(
    pal = pal,
    values = ct_select$RPL_THEMES,
    opacity = 0.7,
    title = "SVI by Tract",
    position = "bottomright"
  ) %>%
  # Add layer controls to toggle views
  addLayersControl(
    baseGroups = c( "CartoDB","OSM", "Imagery"),
    overlayGroups = c("City Outline", "Census Tracts","Highest SVI","Lowest Greenness"),
    options = layersControlOptions(collapsed = FALSE)
  )

map

```


## Policy Recommendations 
### For Community Leaders 
1.  **Tree Canopy Goal:** define and increase urban tree coverage 
2.  **Equity Focus:** Prioritize green infrastructure in underserved neighborhoods 
3.  **Health Integration:** Include health impact assessments in all green space planning 

### For Residents 
1.  **Community Gardens:** Support local initiatives to create neighborhood growing spaces 
2.  **Tree Planting:** Participate in municipal tree planting programs
3.  **Green Advocacy:** Advocate for green space inclusion in new developments 

### For Urban Planners 
1.  **Zoning Requirements:** Mandate minimum green space ratios in new developments
2.  **Green Corridors:** Connect existing parks and green spaces with tree-lined pathways 
3.  **Climate Resilience:** Use vegetation to address urban heat island effects 

---


## Data Sources & Methodology 
This report uses satellite-derived vegetation data (NDVI), U.S. Census demographics, and peer-reviewed health impact models from environmental epidemiology research. Health estimates are based on established exposure-response relationships from longitudinal cohort studies across multiple cities. 

* **Scientific Basis:** Meta-analysis of 8+ million individuals showing 4% mortality reduction per 0.1 NDVI increase 
* **Data Sources:** NASA Landsat, U.S. Census ACS, CDC Social Vulnerability Index, CDC mortality statistics 
* **Geographic Resolution:** Census tract level for SVI analysis, block group level for vegetation data 

---
Report generated by [JustGreen Tool - Colorado State University](https://geocentroid.shinyapps.io/JustGreen/). For questions or technical details, contact: david.rojas@colostate.edu 
